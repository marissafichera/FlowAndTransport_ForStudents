# -*- coding: utf-8 -*-
"""HYD508_HW4_Problems4-3_4-4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18V_Y2GZewii0-ynHEThxs89OdBAc0cm1

HYD508 Homework 4, problems 4.3 - 4.4. Written by Marissa Fichera, 2023-2024

You can change the values of n used in the summation (ns) to see how it affects the profiles.

Change your variables at the bottom of the code to answer the questions in 4.4. (runtime takes a while - be patient)

Check out this cool, short, dense, but very informative video to understand more about how this equation works, why it's hard, why it's good, why it's bad, etc: https://www.youtube.com/watch?v=ToIXSwZ1pJU
"""

import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
import math
import os


def problem_4_3_4(Kt, cp, L, ns, nx):
    T0l = 320  # temp at t=0, left
    T0r = 300  # temp at t = 0, right
    x = np.linspace(0, L, nx)
    D = Kt/cp

    T_i = T0r + (0)*x/L                     # uniform initial temp distribution
    T_f = T0l + (T0r-T0l)*x/L              # final temp distribution

    plt.figure(1)
    plt.plot(x, T_i, label='initial')
    plt.plot(x, T_f, label='final')
    plt.xlabel('x (m)')
    plt.ylabel('temperature (K)')
    plt.title('Initial and final equilibrium temperature profiles')
    plt.legend()

    times = np.linspace(0, 30*60, 10)
    num_nvals = ns
    temps_matrix = [T_i * np.ones_like(x)]


    # summation of sin terms, then calculation/plotting of temp distribution T(x,t)
    i = 1
    for t in times:
        temps_x = []
        qs_x = []
        for h in x:
            sns = []
            for n in np.arange(1, num_nvals+1):
                eterm = D * (n ** 2) * (np.pi ** 2) * t / (L ** 2)
                sn = (1 / n) * np.sin(n * np.pi * h / L) * np.exp(-1*eterm)
                sns.append(sn)
                sum = np.sum(sns)
            # calculate temperature distribution at time t
            temp_at_x_at_t = T0l + ((T0r - T0l) * (h / L)) + ((T0r - T0l) * (2 / np.pi) * sum)
            temps_x.append(temp_at_x_at_t)
        # plot temperature distribution at time t. keep inside (for t in times) loop because Im lazy and don't want to have to store/keep track of/reference everything
        plt.figure(4)
        plt.plot(x, temps_x, label='t={:.1f} s'.format(t))
        plt.legend()
        plt.xlabel('x(m)')
        plt.ylabel('temperature (K)')
        plt.title('Temperature profile of heat transfer with time, x = {}m; Kt = {} W/mK; cp = {} J/kgK'.format(L,Kt,cp))

        temps_matrix.append(temps_x)
        i += 1

    plt.show()

    # problem_4_4_e(x, times, np.array(temps_matrix), Kt)


def problem_4_4_e(x, times, temps, Kt):
    # uncomment problem_4_4_e above, then re-run,
    # increase nx in def main() until you get close to 0.001 for ds:
    ds = x[1] - x[0]
    print(f'ds = {ds}')

    # this will take the temps calculated above and use them to calc the heat flux density
    dTds_left_initial = (temps[0, 1] - temps[0, 0]) / ds
    dTds_right_initial = (temps[0, -1] - temps[0, -2]) / ds

    dTds_left_final =  (temps[-1, 1] - temps[-1, 0]) / ds
    dTds_right_final = (temps[-1, -1] - temps[-1, -2]) / ds

    dTds_i = np.array((dTds_left_initial, dTds_right_initial))
    dTds_f = np.array((dTds_left_final, dTds_right_final))

    qti = -Kt * dTds_i
    qtf = -Kt * dTds_f

    print(f'qT initial (left, right) = {qti}')
    print(f'qT final (left, right) = {qtf}')

    # now plot the transient heat flux at each end w.r.t time:

    dTds_left_transient = (temps[:, 1] - temps[:, 0]) / ds
    dTds_right_transient = (temps[:, -1] - temps[:, -2]) / ds

    qt_left_transient = -Kt * dTds_left_transient
    qt_right_transient = -Kt * dTds_right_transient

    times = times + 100
    times = list(times)
    times.insert(0, 0)

    plt.figure(3)
    plt.plot(times, qt_left_transient, 'bo', label='left')
    plt.plot(times, qt_right_transient, 'g.', label='right')
    plt.xlabel('time (s)')
    plt.ylabel('heat flux density (W/(m^2))')
    plt.title('heat flux density through time')
    plt.legend(bbox_to_anchor = (1.25, 0.6), loc='center right')

    plt.show()


def main():
    ####### CHANGE VARIABLES HERE FOR PROBLEM 4.4 ############
    #### save your plots after each run to compare #####
    ##############################################################

    Kt = 0.609    # in W/mK
    cp = 4184     # in J/kgK
    L = 1         # in m
    ns = 100     # number of n values in summation
    nx = 100      # number of x values between 0 and 1 to evaluate (discretizing x)

    ############################################
    problem_4_3_4(Kt, cp, L, ns, nx)


if __name__ == '__main__':
    main()

_